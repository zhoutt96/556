Test Strategy
1. Component Level
a) Test Ping/Pong independently: test neighbor detection 
First we need to test if our PING/PONG protocol works well independently before testing LS protocol and DV protocol.
So simply, we just use two nodes like the simpletest1 to test: 
	if PING and PONG would send/receive packets successfully
	If updated packets are being sent periodically
	If the cost is correct
So we use the pingpong_test.txt to test if the PING/PONG can detect the linkcoming, linkdying and changedelay periodically, can update the local neighbour status map correctly. We use printPortStatus() function to print the local neighbour information every 10 seconds, to help us do the testing. 

b) Test LS protocol (only):
Then if the PING/PONG works well, we will go further to test our LS protocol:
For this test, it would be more complicated than PING/PONG test, we would not only have [xmit], but also combine with [changedelay], [linkdying], [linkcomingup] to change the cost between neighbors to test:
	If LS protocol would send/receive LSP successfully
	If LS protocol would send/receive data packets successfully
	If the flooding works well and would flooding packets periodically
	If the Dijkstra algorithm works correctly
	If the LS packets update well by sequence number

In order to design the unit test for LS protocol, we have initiate some predefined neighbour information on the node in init() function, and do not involve any PING/PONG communication in the network, in this way, we can detect whether the link state flooding and forwarding table can be calculated correctly. To help debug, we use the print_forwarding_table() and print_flooding_table() in LS.cc to print the information. 

c) Test DV protocol (only):
Similar as testing LS protocol, we would combine [xmit], [changedelay], [linkdying], [linkcomingup] together to test:
	If DV protocol would always record the best path correctly
	If DV protocol would update forwarding table by current best path
	If DV protocol implement the poison reverse correctly
	If DV protocol would update and flood periodically
d) Unit Test for  Data Forwarding:
In order to test if the data packet can be forwarded correctly from the source router to the destination router, we have initialized the pre-defined neighbour status map (which should generated by PING/PONG), pre-defined flooding table(which should generated by  LS flooding), and pre-defined forwarding table (which should be generated by Dijkstra algorithm, and DV protocol), based on these information, we only involve xmit() in the test file, to test whether the data packet is sent through expected path. 
	
2.System Level
After we test our project by component level and there is no bug, it means both LS and DV protocols work well independently. So for our system level, we would test the whole LS and DV protocol separately. We would test our project from an easy scenario (like just 3 nodes and simple events) in the system to a more complicated level (like 10 nodes and more complicated events combination), in order to test our project work well on the whole system level.

3. Test Case
We would give a complicated test case to test our whole LS and DV protocol finally. 

pingpong_test :
[nodes]

1 2 3 4 5 6 7 8 9 10

[links]

(1,2) delay 0.010 prob 0.0
(1,10) delay 0.030 prob 0.0
(2,3) delay 0.010 prob 0.0
(2,4) delay 0.060 prob 0.0
(2,9) delay 0.010 prob 0.0
(3,5) delay 0.020 prob 0.0
(4,8) delay 0.030 prob 0.0
(5,7) delay 0.040 prob 0.0
(6,7) delay 0.020 prob 0.0
(7,10) delay 0.040 prob 0.0
(8,9) delay 0.010 prob 0.0

[events]

140.00 changedelay (3,5) 0.040
250.00 linkdying (1,2)
400.00 linkdying (1,10)
500.00 linkcomingup(1,2)
600.00 end

==========================================================================
comprehensive test

[nodes]

1 2 3 4 5 6 7 8 9 10

[links]

(1,2) delay 0.010 prob 0.0
(1,10) delay 0.030 prob 0.0
(2,3) delay 0.010 prob 0.0
(2,4) delay 0.060 prob 0.0
(2,9) delay 0.010 prob 0.0
(3,5) delay 0.020 prob 0.0
(4,8) delay 0.030 prob 0.0
(5,7) delay 0.040 prob 0.0
(6,7) delay 0.020 prob 0.0
(7,10) delay 0.040 prob 0.0
(8,9) delay 0.010 prob 0.0

[events]

100.00  xmit (1,9)
140.00 changedelay (3,5) 0.040
190.00 xmit (7,1)
250.00 linkdying (1,2)
350.00 xmit (9,1)
400.00 linkdying (1,10)
440.00 xmit (1,8)
460.00 xmit (2,8)
490.00 linkcomingup(1,2)
550.00 xmit(9, 1)
600.00 end


Here is how we cover all conner cases in this test:
Three typical cases when Neighbour status updating is needed:
	Time = 150: Because the delay between node 3 and node 5 have changed, so when time = 150, the node 3 and node 5 should update the neighbor status table in theory. 
	Time = 260/410:  the node 1 and node 2 should update the neighbor status table, due to the linkdying before 10 seconds. 
	Time = 510: the node 1 and node 10 should update the neighbour status table due to the linkcoming up before 10 seconds. 

LS flooding table update:
	Time = 150: node 3 and node 5 should update the flooding table because of the neighbour status information updating. 
	Time = 270: node 1 and node 2 should update the flooding table because of the neighbour status information updating. 
	Time = 420: node 1 and node 10 should update the flooding table because of the neighbour status information updating. 
	Time = 510: node 1 and node 2 should update the flooding table because of the neighbour status information updating. 

Expected Path:
	Time = 100, xmit (1,9), the path should be 1->2->9
	Time = 190, xmit(7,1), the path should be 7->5->3->2->1
	Time = 350, xmit(9,1), the path should be 9->2->3->5->7->10
	Time = 440, xmit(1,8), can not reach 
	Time = 460, xmit(2,8), the path should be 2->9->8
	Time = 550, xmit(9,1), the path should be 9->2->1


In conclusion, we design a dynamic network which contains as many as possible cases, and we have calculated the expected events in advance, then we will run our program, and take a look at whether the events are the same as expected. 

